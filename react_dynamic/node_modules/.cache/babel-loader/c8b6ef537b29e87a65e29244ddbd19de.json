{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function wrap(fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function _await(value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction $(expr, con) {\n  return typeof expr === \"string\" ? (con || document).querySelector(expr) : expr || null;\n}\n\nvar EASING = {\n  ease: \"0.25 0.1 0.25 1\",\n  linear: \"0 0 1 1\",\n  // easein: \"0.42 0 1 1\",\n  easein: \"0.1 0.8 0.2 1\",\n  easeout: \"0 0 0.58 1\",\n  easeinout: \"0.42 0 0.58 1\"\n};\n\n$.findNodeIndex = function (node) {\n  var i = 0;\n\n  while (node.previousSibling) {\n    node = node.previousSibling;\n    i++;\n  }\n\n  return i;\n};\n\n$.create = function (tag, o) {\n  var element = document.createElement(tag);\n\n  for (var i in o) {\n    var val = o[i];\n\n    if (i === \"inside\") {\n      $(val).appendChild(element);\n    } else if (i === \"around\") {\n      var ref = $(val);\n      ref.parentNode.insertBefore(element, ref);\n      element.appendChild(ref);\n    } else if (i === \"styles\") {\n      if ((typeof val === \"undefined\" ? \"undefined\" : _typeof(val)) === \"object\") {\n        Object.keys(val).map(function (prop) {\n          element.style[prop] = val[prop];\n        });\n      }\n    } else if (i in element) {\n      element[i] = val;\n    } else {\n      element.setAttribute(i, val);\n    }\n  }\n\n  return element;\n};\n\n$.createSVG = function (tag, o) {\n  var element = document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n\n  for (var i in o) {\n    var val = o[i];\n\n    if (i === \"inside\") {\n      $(val).appendChild(element);\n    } else if (i === \"around\") {\n      var ref = $(val);\n      ref.parentNode.insertBefore(element, ref);\n      element.appendChild(ref);\n    } else {\n      if (i === \"className\") {\n        i = \"class\";\n      }\n\n      if (i === \"innerHTML\") {\n        element['textContent'] = val;\n      } else {\n        element.setAttribute(i, val);\n      }\n    }\n  }\n\n  return element;\n};\n\n$.runSVGAnimation = function (svg_container, elements) {\n  // let parent = elements[0][0]['unit'].parentNode;\n  var new_elements = [];\n  var anim_elements = [];\n  elements.map(function (element) {\n    var obj = element[0];\n    var parent = obj.unit.parentNode; // let index = let findNodeIndex(obj.unit);\n\n    var anim_element = void 0,\n        new_element = void 0;\n    element[0] = obj.unit;\n\n    var _$$animateSVG = $.animateSVG.apply($, toConsumableArray(element));\n\n    var _$$animateSVG2 = slicedToArray(_$$animateSVG, 2);\n\n    anim_element = _$$animateSVG2[0];\n    new_element = _$$animateSVG2[1];\n    new_elements.push(new_element);\n    anim_elements.push([anim_element, parent]);\n    parent.replaceChild(anim_element, obj.unit);\n\n    if (obj.array) {\n      obj.array[obj.index] = new_element;\n    } else {\n      obj.object[obj.key] = new_element;\n    }\n  });\n  var anim_svg = svg_container.cloneNode(true);\n  anim_elements.map(function (anim_element, i) {\n    anim_element[1].replaceChild(new_elements[i], anim_element[0]);\n    elements[i][0] = new_elements[i];\n  });\n  return anim_svg;\n};\n\n$.transform = function (element, style) {\n  element.style.transform = style;\n  element.style.webkitTransform = style;\n  element.style.msTransform = style;\n  element.style.mozTransform = style;\n  element.style.oTransform = style;\n};\n\n$.animateSVG = function (element, props, dur) {\n  var easing_type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"linear\";\n  var type = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n  var old_values = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  var anim_element = element.cloneNode(true);\n  var new_element = element.cloneNode(true);\n\n  for (var attributeName in props) {\n    var animate_element = void 0;\n\n    if (attributeName === 'transform') {\n      animate_element = document.createElementNS(\"http://www.w3.org/2000/svg\", \"animateTransform\");\n    } else {\n      animate_element = document.createElementNS(\"http://www.w3.org/2000/svg\", \"animate\");\n    }\n\n    var current_value = old_values[attributeName] || element.getAttribute(attributeName);\n    var value = props[attributeName];\n    var anim_attr = {\n      attributeName: attributeName,\n      from: current_value,\n      to: value,\n      begin: \"0s\",\n      dur: dur / 1000 + \"s\",\n      values: current_value + \";\" + value,\n      keySplines: EASING[easing_type],\n      keyTimes: \"0;1\",\n      calcMode: \"spline\",\n      fill: 'freeze'\n    };\n\n    if (type) {\n      anim_attr[\"type\"] = type;\n    }\n\n    for (var i in anim_attr) {\n      animate_element.setAttribute(i, anim_attr[i]);\n    }\n\n    anim_element.appendChild(animate_element);\n\n    if (type) {\n      new_element.setAttribute(attributeName, \"translate(\" + value + \")\");\n    } else {\n      new_element.setAttribute(attributeName, value);\n    }\n  }\n\n  return [anim_element, new_element];\n};\n\n$.offset = function (element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    // https://stackoverflow.com/a/7436602/6495043\n    // rect.top varies with scroll, so we add whatever has been\n    // scrolled to it to get absolute distance from actual page top\n    top: rect.top + (document.documentElement.scrollTop || document.body.scrollTop),\n    left: rect.left + (document.documentElement.scrollLeft || document.body.scrollLeft)\n  };\n};\n\n$.isElementInViewport = function (el) {\n  // Although straightforward: https://stackoverflow.com/a/7557433/6495043\n  var rect = el.getBoundingClientRect();\n  return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n  /*or $(window).height() */\n  rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n  /*or $(window).width() */\n  ;\n};\n\n$.bind = function (element, o) {\n  if (element) {\n    for (var event in o) {\n      var callback = o[event];\n      event.split(/\\s+/).forEach(function (event) {\n        element.addEventListener(event, callback);\n      });\n    }\n  }\n};\n\n$.unbind = function (element, o) {\n  if (element) {\n    for (var event in o) {\n      var callback = o[event];\n      event.split(/\\s+/).forEach(function (event) {\n        element.removeEventListener(event, callback);\n      });\n    }\n  }\n};\n\n$.fire = function (target, type, properties) {\n  var evt = document.createEvent(\"HTMLEvents\");\n  evt.initEvent(type, true, true);\n\n  for (var j in properties) {\n    evt[j] = properties[j];\n  }\n\n  return target.dispatchEvent(evt);\n};\n\nfunction float_2(d) {\n  return parseFloat(d.toFixed(2));\n}\n\nfunction arrays_equal(arr1, arr2) {\n  if (arr1.length !== arr2.length) return false;\n  var are_equal = true;\n  arr1.map(function (d, i) {\n    if (arr2[i] !== d) are_equal = false;\n  });\n  return are_equal;\n}\n\nfunction limitColor(r) {\n  if (r > 255) return 255;else if (r < 0) return 0;\n  return r;\n}\n\nfunction lightenDarkenColor(col, amt) {\n  var usePound = false;\n\n  if (col[0] == \"#\") {\n    col = col.slice(1);\n    usePound = true;\n  }\n\n  var num = parseInt(col, 16);\n  var r = limitColor((num >> 16) + amt);\n  var b = limitColor((num >> 8 & 0x00FF) + amt);\n  var g = limitColor((num & 0x0000FF) + amt);\n  return (usePound ? \"#\" : \"\") + (g | b << 8 | r << 16).toString(16);\n}\n/**\n * Shuffles array in place. ES6 version\n * @param {Array} a items An array containing the items.\n */\n\n\nvar SvgTip = function () {\n  function SvgTip(_ref) {\n    var _ref$parent = _ref.parent,\n        parent = _ref$parent === undefined ? null : _ref$parent;\n    classCallCheck(this, SvgTip);\n    this.parent = parent;\n    this.title_name = '';\n    this.title_value = '';\n    this.list_values = [];\n    this.title_value_first = 0;\n    this.x = 0;\n    this.y = 0;\n    this.top = 0;\n    this.left = 0;\n    this.setup();\n  }\n\n  createClass(SvgTip, [{\n    key: 'setup',\n    value: function setup() {\n      this.make_tooltip();\n    }\n  }, {\n    key: 'refresh',\n    value: function refresh() {\n      this.fill();\n      this.calc_position(); // this.show_tip();\n    }\n  }, {\n    key: 'make_tooltip',\n    value: function make_tooltip() {\n      var _this = this;\n\n      this.container = $.create('div', {\n        inside: this.parent,\n        className: 'graph-svg-tip comparison',\n        innerHTML: '<span class=\"title\"></span>\\n\\t\\t\\t\\t<ul class=\"data-point-list\"></ul>\\n\\t\\t\\t\\t<div class=\"svg-pointer\"></div>'\n      });\n      this.hide_tip();\n      this.title = this.container.querySelector('.title');\n      this.data_point_list = this.container.querySelector('.data-point-list');\n      this.parent.addEventListener('mouseleave', function () {\n        _this.hide_tip();\n      });\n    }\n  }, {\n    key: 'fill',\n    value: function fill() {\n      var _this2 = this;\n\n      var title = void 0;\n\n      if (this.title_value_first) {\n        title = '<strong>' + this.title_value + '</strong>' + this.title_name;\n      } else {\n        title = this.title_name + '<strong>' + this.title_value + '</strong>';\n      }\n\n      this.title.innerHTML = title;\n      this.data_point_list.innerHTML = '';\n      this.list_values.map(function (set$$1) {\n        var li = $.create('li', {\n          className: 'border-top ' + (set$$1.color || 'black'),\n          innerHTML: '<strong style=\"display: block;\">' + (isNaN(set$$1.value) ? '' : set$$1.value) + '</strong>\\n\\t\\t\\t\\t\\t' + (set$$1.title ? set$$1.title : '')\n        });\n\n        _this2.data_point_list.appendChild(li);\n      });\n    }\n  }, {\n    key: 'calc_position',\n    value: function calc_position() {\n      this.top = this.y - this.container.offsetHeight;\n      this.left = this.x - this.container.offsetWidth / 2;\n      var max_left = this.parent.offsetWidth - this.container.offsetWidth;\n      var pointer = this.container.querySelector('.svg-pointer');\n\n      if (this.left < 0) {\n        pointer.style.left = 'calc(50% - ' + -1 * this.left + 'px)';\n        this.left = 0;\n      } else if (this.left > max_left) {\n        var delta = this.left - max_left;\n        pointer.style.left = 'calc(50% + ' + delta + 'px)';\n        this.left = max_left;\n      } else {\n        pointer.style.left = '50%';\n      }\n    }\n  }, {\n    key: 'set_values',\n    value: function set_values(x, y) {\n      var title_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var title_value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n      var list_values = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n      var title_value_first = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n      this.title_name = title_name;\n      this.title_value = title_value;\n      this.list_values = list_values;\n      this.x = x;\n      this.y = y;\n      this.title_value_first = title_value_first;\n      this.refresh();\n    }\n  }, {\n    key: 'hide_tip',\n    value: function hide_tip() {\n      this.container.style.top = '0px';\n      this.container.style.left = '0px';\n      this.container.style.opacity = '0';\n    }\n  }, {\n    key: 'show_tip',\n    value: function show_tip() {\n      this.container.style.top = this.top + 'px';\n      this.container.style.left = this.left + 'px';\n      this.container.style.opacity = '1';\n    }\n  }]);\n  return SvgTip;\n}();\n\nvar BaseChart = function () {\n  function BaseChart(_ref) {\n    var _ref$height = _ref.height,\n        height = _ref$height === undefined ? 240 : _ref$height,\n        _ref$title = _ref.title,\n        title = _ref$title === undefined ? '' : _ref$title,\n        _ref$subtitle = _ref.subtitle,\n        subtitle = _ref$subtitle === undefined ? '' : _ref$subtitle,\n        _ref$format_lambdas = _ref.format_lambdas,\n        format_lambdas = _ref$format_lambdas === undefined ? {} : _ref$format_lambdas,\n        _ref$summary = _ref.summary,\n        summary = _ref$summary === undefined ? [] : _ref$summary,\n        _ref$is_navigable = _ref.is_navigable,\n        is_navigable = _ref$is_navigable === undefined ? 0 : _ref$is_navigable,\n        _ref$has_legend = _ref.has_legend,\n        has_legend = _ref$has_legend === undefined ? 0 : _ref$has_legend,\n        _ref$type = _ref.type,\n        type = _ref$type === undefined ? '' : _ref$type,\n        parent = _ref.parent,\n        data = _ref.data;\n    classCallCheck(this, BaseChart);\n    this.raw_chart_args = arguments[0];\n    this.parent = typeof parent === 'string' ? document.querySelector(parent) : parent;\n    this.title = title;\n    this.subtitle = subtitle;\n    this.data = data;\n    this.format_lambdas = format_lambdas;\n    this.specific_values = data.specific_values || [];\n    this.summary = summary;\n    this.is_navigable = is_navigable;\n\n    if (this.is_navigable) {\n      this.current_index = 0;\n    }\n\n    this.has_legend = has_legend;\n    this.chart_types = ['line', 'scatter', 'bar', 'percentage', 'heatmap', 'pie'];\n    this.set_margins(height);\n  }\n\n  createClass(BaseChart, [{\n    key: 'get_different_chart',\n    value: function get_different_chart(type) {\n      if (!this.chart_types.includes(type)) {\n        console.error('\\'' + type + '\\' is not a valid chart type.');\n      }\n\n      if (type === this.type) return; // Only across compatible types\n\n      var compatible_types = {\n        bar: ['line', 'scatter', 'percentage', 'pie'],\n        line: ['scatter', 'bar', 'percentage', 'pie'],\n        pie: ['line', 'scatter', 'percentage', 'bar'],\n        scatter: ['line', 'bar', 'percentage', 'pie'],\n        percentage: ['bar', 'line', 'scatter', 'pie'],\n        heatmap: []\n      };\n\n      if (!compatible_types[this.type].includes(type)) {\n        console.error('\\'' + this.type + '\\' chart cannot be converted to a \\'' + type + '\\' chart.');\n      } // Okay, this is anticlimactic\n      // this function will need to actually be 'change_chart_type(type)'\n      // that will update only the required elements, but for now ...\n\n\n      return new Chart({\n        parent: this.raw_chart_args.parent,\n        title: this.title,\n        data: this.raw_chart_args.data,\n        type: type,\n        height: this.raw_chart_args.height\n      });\n    }\n  }, {\n    key: 'set_margins',\n    value: function set_margins(height) {\n      this.base_height = height;\n      this.height = height - 40;\n      this.translate_x = 60;\n      this.translate_y = 10;\n    }\n  }, {\n    key: 'setup',\n    value: function setup() {\n      if (!this.parent) {\n        console.error(\"No parent element to render on was provided.\");\n        return;\n      }\n\n      this.bind_window_events();\n      this.refresh(true);\n    }\n  }, {\n    key: 'bind_window_events',\n    value: function bind_window_events() {\n      var _this = this;\n\n      window.addEventListener('resize', function () {\n        return _this.refresh();\n      });\n      window.addEventListener('orientationchange', function () {\n        return _this.refresh();\n      });\n    }\n  }, {\n    key: 'refresh',\n    value: function refresh() {\n      var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.setup_base_values();\n      this.set_width();\n      this.setup_container();\n      this.setup_components();\n      this.setup_values();\n      this.setup_utils();\n      this.make_graph_components(init);\n      this.make_tooltip();\n\n      if (this.summary.length > 0) {\n        this.show_custom_summary();\n      } else {\n        this.show_summary();\n      }\n\n      if (this.is_navigable) {\n        this.setup_navigation(init);\n      }\n    }\n  }, {\n    key: 'set_width',\n    value: function set_width() {\n      var _this2 = this;\n\n      var special_values_width = 0;\n      this.specific_values.map(function (val) {\n        if (_this2.get_strwidth(val.title) > special_values_width) {\n          special_values_width = _this2.get_strwidth(val.title) - 40;\n        }\n      });\n      this.base_width = this.parent.offsetWidth - special_values_width;\n      this.width = this.base_width - this.translate_x * 2;\n    }\n  }, {\n    key: 'setup_base_values',\n    value: function setup_base_values() {}\n  }, {\n    key: 'setup_container',\n    value: function setup_container() {\n      this.container = $.create('div', {\n        className: 'chart-container',\n        innerHTML: '<h6 class=\"title\">' + this.title + '</h6>\\n\\t\\t\\t\\t<h6 class=\"sub-title uppercase\">' + this.subtitle + '</h6>\\n\\t\\t\\t\\t<div class=\"frappe-chart graphics\"></div>\\n\\t\\t\\t\\t<div class=\"graph-stats-container\"></div>'\n      }); // Chart needs a dedicated parent element\n\n      this.parent.innerHTML = '';\n      this.parent.appendChild(this.container);\n      this.chart_wrapper = this.container.querySelector('.frappe-chart');\n      this.stats_wrapper = this.container.querySelector('.graph-stats-container');\n      this.make_chart_area();\n      this.make_draw_area();\n    }\n  }, {\n    key: 'make_chart_area',\n    value: function make_chart_area() {\n      this.svg = $.createSVG('svg', {\n        className: 'chart',\n        inside: this.chart_wrapper,\n        width: this.base_width,\n        height: this.base_height\n      });\n      this.svg_defs = $.createSVG('defs', {\n        inside: this.svg\n      });\n      return this.svg;\n    }\n  }, {\n    key: 'make_draw_area',\n    value: function make_draw_area() {\n      this.draw_area = $.createSVG(\"g\", {\n        className: this.type + '-chart',\n        inside: this.svg,\n        transform: 'translate(' + this.translate_x + ', ' + this.translate_y + ')'\n      });\n    }\n  }, {\n    key: 'setup_components',\n    value: function setup_components() {}\n  }, {\n    key: 'make_tooltip',\n    value: function make_tooltip() {\n      this.tip = new SvgTip({\n        parent: this.chart_wrapper\n      });\n      this.bind_tooltip();\n    }\n  }, {\n    key: 'show_summary',\n    value: function show_summary() {}\n  }, {\n    key: 'show_custom_summary',\n    value: function show_custom_summary() {\n      var _this3 = this;\n\n      this.summary.map(function (d) {\n        var stats = $.create('div', {\n          className: 'stats',\n          innerHTML: '<span class=\"indicator ' + d.color + '\">' + d.title + ': ' + d.value + '</span>'\n        });\n\n        _this3.stats_wrapper.appendChild(stats);\n      });\n    }\n  }, {\n    key: 'setup_navigation',\n    value: function setup_navigation() {\n      var _this4 = this;\n\n      var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.make_overlay();\n\n      if (init) {\n        this.bind_overlay();\n        document.addEventListener('keydown', function (e) {\n          if ($.isElementInViewport(_this4.chart_wrapper)) {\n            e = e || window.event;\n\n            if (e.keyCode == '37') {\n              _this4.on_left_arrow();\n            } else if (e.keyCode == '39') {\n              _this4.on_right_arrow();\n            } else if (e.keyCode == '38') {\n              _this4.on_up_arrow();\n            } else if (e.keyCode == '40') {\n              _this4.on_down_arrow();\n            } else if (e.keyCode == '13') {\n              _this4.on_enter_key();\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: 'make_overlay',\n    value: function make_overlay() {}\n  }, {\n    key: 'bind_overlay',\n    value: function bind_overlay() {}\n  }, {\n    key: 'bind_units',\n    value: function bind_units() {}\n  }, {\n    key: 'on_left_arrow',\n    value: function on_left_arrow() {}\n  }, {\n    key: 'on_right_arrow',\n    value: function on_right_arrow() {}\n  }, {\n    key: 'on_up_arrow',\n    value: function on_up_arrow() {}\n  }, {\n    key: 'on_down_arrow',\n    value: function on_down_arrow() {}\n  }, {\n    key: 'on_enter_key',\n    value: function on_enter_key() {}\n  }, {\n    key: 'get_data_point',\n    value: function get_data_point() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.current_index; // check for length\n\n      var data_point = {\n        index: index\n      };\n      var y = this.y[0];\n      ['svg_units', 'y_tops', 'values'].map(function (key) {\n        var data_key = key.slice(0, key.length - 1);\n        data_point[data_key] = y[key][index];\n      });\n      data_point.label = this.x[index];\n      return data_point;\n    }\n  }, {\n    key: 'update_current_data_point',\n    value: function update_current_data_point(index) {\n      index = parseInt(index);\n      if (index < 0) index = 0;\n      if (index >= this.x.length) index = this.x.length - 1;\n      if (index === this.current_index) return;\n      this.current_index = index;\n      $.fire(this.parent, \"data-select\", this.get_data_point());\n    } // Helpers\n\n  }, {\n    key: 'get_strwidth',\n    value: function get_strwidth(string) {\n      return (string + \"\").length * 8;\n    } // Objects\n\n  }, {\n    key: 'setup_utils',\n    value: function setup_utils() {}\n  }]);\n  return BaseChart;\n}();\n\nvar AxisChart = function (_BaseChart) {\n  inherits(AxisChart, _BaseChart);\n\n  function AxisChart(args) {\n    classCallCheck(this, AxisChart);\n\n    var _this = possibleConstructorReturn(this, (AxisChart.__proto__ || Object.getPrototypeOf(AxisChart)).call(this, args));\n\n    _this.x = _this.data.labels;\n    _this.y = _this.data.datasets;\n    _this.is_series = args.is_series;\n    _this.get_y_label = _this.format_lambdas.y_label;\n    _this.get_y_tooltip = _this.format_lambdas.y_tooltip;\n    _this.get_x_tooltip = _this.format_lambdas.x_tooltip;\n    _this.colors = ['green', 'blue', 'violet', 'red', 'orange', 'yellow', 'light-blue', 'light-green', 'purple', 'magenta'];\n    _this.zero_line = _this.height;\n    return _this;\n  }\n\n  createClass(AxisChart, [{\n    key: 'setup_values',\n    value: function setup_values() {\n      this.data.datasets.map(function (d) {\n        d.values = d.values.map(function (val) {\n          return !isNaN(val) ? val : 0;\n        });\n      });\n      this.setup_x();\n      this.setup_y();\n    }\n  }, {\n    key: 'setup_x',\n    value: function setup_x() {\n      var _this2 = this;\n\n      this.set_avg_unit_width_and_x_offset();\n\n      if (this.x_axis_positions) {\n        this.x_old_axis_positions = this.x_axis_positions.slice();\n      }\n\n      this.x_axis_positions = this.x.map(function (d, i) {\n        return float_2(_this2.x_offset + i * _this2.avg_unit_width);\n      });\n\n      if (!this.x_old_axis_positions) {\n        this.x_old_axis_positions = this.x_axis_positions.slice();\n      }\n    }\n  }, {\n    key: 'setup_y',\n    value: function setup_y() {\n      if (this.y_axis_values) {\n        this.y_old_axis_values = this.y_axis_values.slice();\n      }\n\n      var values = this.get_all_y_values();\n\n      if (this.y_sums && this.y_sums.length > 0) {\n        values = values.concat(this.y_sums);\n      }\n\n      this.y_axis_values = this.get_y_axis_points(values);\n\n      if (!this.y_old_axis_values) {\n        this.y_old_axis_values = this.y_axis_values.slice();\n      }\n\n      var y_pts = this.y_axis_values;\n      var value_range = y_pts[y_pts.length - 1] - y_pts[0];\n      if (this.multiplier) this.old_multiplier = this.multiplier;\n      this.multiplier = this.height / value_range;\n      if (!this.old_multiplier) this.old_multiplier = this.multiplier;\n      var zero_index = y_pts.indexOf(0);\n      var interval = y_pts[1] - y_pts[0];\n      var interval_height = interval * this.multiplier;\n      if (this.zero_line) this.old_zero_line = this.zero_line;\n      this.zero_line = this.height - zero_index * interval_height;\n      if (!this.old_zero_line) this.old_zero_line = this.zero_line;\n    }\n  }, {\n    key: 'setup_components',\n    value: function setup_components() {\n      get(AxisChart.prototype.__proto__ || Object.getPrototypeOf(AxisChart.prototype), 'setup_components', this).call(this);\n      this.setup_marker_components();\n      this.setup_aggregation_components();\n      this.setup_graph_components();\n    }\n  }, {\n    key: 'setup_marker_components',\n    value: function setup_marker_components() {\n      this.y_axis_group = $.createSVG('g', {\n        className: 'y axis',\n        inside: this.draw_area\n      });\n      this.x_axis_group = $.createSVG('g', {\n        className: 'x axis',\n        inside: this.draw_area\n      });\n      this.specific_y_group = $.createSVG('g', {\n        className: 'specific axis',\n        inside: this.draw_area\n      });\n    }\n  }, {\n    key: 'setup_aggregation_components',\n    value: function setup_aggregation_components() {\n      this.sum_group = $.createSVG('g', {\n        className: 'data-points',\n        inside: this.draw_area\n      });\n      this.average_group = $.createSVG('g', {\n        className: 'chart-area',\n        inside: this.draw_area\n      });\n    }\n  }, {\n    key: 'setup_graph_components',\n    value: function setup_graph_components() {\n      var _this3 = this;\n\n      this.svg_units_groups = [];\n      this.y.map(function (d, i) {\n        _this3.svg_units_groups[i] = $.createSVG('g', {\n          className: 'data-points data-points-' + i,\n          inside: _this3.draw_area\n        });\n      });\n    }\n  }, {\n    key: 'make_graph_components',\n    value: function make_graph_components() {\n      var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.make_y_axis();\n      this.make_x_axis();\n      this.draw_graph(init);\n      this.make_y_specifics();\n    } // make VERTICAL lines for x values\n\n  }, {\n    key: 'make_x_axis',\n    value: function make_x_axis() {\n      var _this4 = this;\n\n      var animate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var start_at = void 0,\n          height = void 0,\n          text_start_at = void 0,\n          axis_line_class = '';\n\n      if (this.x_axis_mode === 'span') {\n        // long spanning lines\n        start_at = -7;\n        height = this.height + 15;\n        text_start_at = this.height + 25;\n      } else if (this.x_axis_mode === 'tick') {\n        // short label lines\n        start_at = this.height;\n        height = 6;\n        text_start_at = 9;\n        axis_line_class = 'x-axis-label';\n      }\n\n      this.x_axis_group.setAttribute('transform', 'translate(0,' + start_at + ')');\n\n      if (animate) {\n        this.make_anim_x_axis(height, text_start_at, axis_line_class);\n        return;\n      }\n\n      var allowed_space = this.avg_unit_width * 1.5;\n      var allowed_letters = allowed_space / 8;\n      this.x_axis_group.textContent = '';\n      this.x.map(function (point, i) {\n        var space_taken = _this4.get_strwidth(point) + 2;\n\n        if (space_taken > allowed_space) {\n          if (_this4.is_series) {\n            // Skip some axis lines if X axis is a series\n            var skips = 1;\n\n            while (space_taken / skips * 2 > allowed_space) {\n              skips++;\n            }\n\n            if (i % skips !== 0) {\n              return;\n            }\n          } else {\n            point = point.slice(0, allowed_letters - 3) + \" ...\";\n          }\n        }\n\n        _this4.x_axis_group.appendChild(_this4.make_x_line(height, text_start_at, point, 'x-value-text', axis_line_class, _this4.x_axis_positions[i]));\n      });\n    } // make HORIZONTAL lines for y values\n\n  }, {\n    key: 'make_y_axis',\n    value: function make_y_axis() {\n      var _this5 = this;\n\n      var animate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (animate) {\n        this.make_anim_y_axis();\n        this.make_anim_y_specifics();\n        return;\n      }\n\n      var _get_y_axis_line_prop = this.get_y_axis_line_props(),\n          _get_y_axis_line_prop2 = slicedToArray(_get_y_axis_line_prop, 4),\n          width = _get_y_axis_line_prop2[0],\n          text_end_at = _get_y_axis_line_prop2[1],\n          axis_line_class = _get_y_axis_line_prop2[2],\n          start_at = _get_y_axis_line_prop2[3];\n\n      this.y_axis_group.textContent = '';\n      this.y_axis_values.map(function (value, i) {\n        _this5.y_axis_group.appendChild(_this5.make_y_line(start_at, width, text_end_at, value, 'y-value-text', axis_line_class, _this5.zero_line - value * _this5.multiplier, value === 0 && i !== 0 // Non-first Zero line\n        ));\n      });\n    }\n  }, {\n    key: 'get_y_axis_line_props',\n    value: function get_y_axis_line_props() {\n      var specific = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (specific) {\n        return [this.width, this.width + 5, 'specific-value', 0];\n      }\n\n      var width = void 0,\n          text_end_at = -9,\n          axis_line_class = '',\n          start_at = 0;\n\n      if (this.y_axis_mode === 'span') {\n        // long spanning lines\n        width = this.width + 6;\n        start_at = -6;\n      } else if (this.y_axis_mode === 'tick') {\n        // short label lines\n        width = -6;\n        axis_line_class = 'y-axis-label';\n      }\n\n      return [width, text_end_at, axis_line_class, start_at];\n    }\n  }, {\n    key: 'draw_graph',\n    value: function draw_graph() {\n      var _this6 = this;\n\n      var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.raw_chart_args.hasOwnProperty(\"init\") && !this.raw_chart_args.init) {\n        this.y.map(function (d, i) {\n          d.svg_units = [];\n          _this6.make_path && _this6.make_path(d, i, _this6.x_axis_positions, d.y_tops, d.color || _this6.colors[i]);\n\n          _this6.make_new_units(d, i);\n\n          _this6.calc_y_dependencies();\n        });\n        return;\n      }\n\n      if (init) {\n        this.draw_new_graph_and_animate();\n        return;\n      }\n\n      this.y.map(function (d, i) {\n        d.svg_units = [];\n        _this6.make_path && _this6.make_path(d, i, _this6.x_axis_positions, d.y_tops, d.color || _this6.colors[i]);\n\n        _this6.make_new_units(d, i);\n      });\n    }\n  }, {\n    key: 'draw_new_graph_and_animate',\n    value: function draw_new_graph_and_animate() {\n      var _this7 = this;\n\n      var data = [];\n      this.y.map(function (d, i) {\n        // Anim: Don't draw initial values, store them and update later\n        d.y_tops = new Array(d.values.length).fill(_this7.zero_line); // no value\n\n        data.push({\n          values: d.values\n        });\n        d.svg_units = [];\n        _this7.make_path && _this7.make_path(d, i, _this7.x_axis_positions, d.y_tops, d.color || _this7.colors[i]);\n\n        _this7.make_new_units(d, i);\n      });\n      setTimeout(function () {\n        _this7.update_values(data);\n      }, 350);\n    }\n  }, {\n    key: 'setup_navigation',\n    value: function setup_navigation(init) {\n      var _this8 = this;\n\n      if (init) {\n        // Hack: defer nav till initial update_values\n        setTimeout(function () {\n          get(AxisChart.prototype.__proto__ || Object.getPrototypeOf(AxisChart.prototype), 'setup_navigation', _this8).call(_this8, init);\n        }, 500);\n      } else {\n        get(AxisChart.prototype.__proto__ || Object.getPrototypeOf(AxisChart.prototype), 'setup_navigation', this).call(this, init);\n      }\n    }\n  }, {\n    key: 'make_new_units',\n    value: function make_new_units(d, i) {\n      this.make_new_units_for_dataset(this.x_axis_positions, d.y_tops, d.color || this.colors[i], i, this.y.length);\n    }\n  }, {\n    key: 'make_new_units_for_dataset',\n    value: function make_new_units_for_dataset(x_values, y_values, color, dataset_index, no_of_datasets, units_group, units_array, unit) {\n      var _this9 = this;\n\n      if (!units_group) units_group = this.svg_units_groups[dataset_index];\n      if (!units_array) units_array = this.y[dataset_index].svg_units;\n      if (!unit) unit = this.unit_args;\n      units_group.textContent = '';\n      units_array.length = 0;\n      y_values.map(function (y, i) {\n        var data_unit = _this9.draw[unit.type](x_values[i], y, unit.args, color, i, dataset_index, no_of_datasets);\n\n        units_group.appendChild(data_unit);\n        units_array.push(data_unit);\n      });\n\n      if (this.is_navigable) {\n        this.bind_units(units_array);\n      }\n    }\n  }, {\n    key: 'make_y_specifics',\n    value: function make_y_specifics() {\n      var _this10 = this;\n\n      this.specific_y_group.textContent = '';\n      this.specific_values.map(function (d) {\n        _this10.specific_y_group.appendChild(_this10.make_y_line(0, _this10.width, _this10.width + 5, d.title.toUpperCase(), 'specific-value', 'specific-value', _this10.zero_line - d.value * _this10.multiplier, false, d.line_type));\n      });\n    }\n  }, {\n    key: 'bind_tooltip',\n    value: function bind_tooltip() {\n      var _this11 = this; // TODO: could be in tooltip itself, as it is a given functionality for its parent\n\n\n      this.chart_wrapper.addEventListener('mousemove', function (e) {\n        var offset = $.offset(_this11.chart_wrapper);\n        var relX = e.pageX - offset.left - _this11.translate_x;\n        var relY = e.pageY - offset.top - _this11.translate_y;\n\n        if (relY < _this11.height + _this11.translate_y * 2) {\n          _this11.map_tooltip_x_position_and_show(relX);\n        } else {\n          _this11.tip.hide_tip();\n        }\n      });\n    }\n  }, {\n    key: 'map_tooltip_x_position_and_show',\n    value: function map_tooltip_x_position_and_show(relX) {\n      var _this12 = this;\n\n      if (!this.y_min_tops) return;\n\n      for (var i = this.x_axis_positions.length - 1; i >= 0; i--) {\n        var x_val = this.x_axis_positions[i]; // let delta = i === 0 ? this.avg_unit_width : x_val - this.x_axis_positions[i-1];\n\n        if (relX > x_val - this.avg_unit_width / 2) {\n          var x = x_val + this.translate_x;\n          var y = this.y_min_tops[i] + this.translate_y;\n          var title = this.x.formatted && this.x.formatted.length > 0 ? this.x.formatted[i] : this.x[i];\n          var values = this.y.map(function (set$$1, j) {\n            return {\n              title: set$$1.title,\n              value: set$$1.formatted ? set$$1.formatted[i] : set$$1.values[i],\n              color: set$$1.color || _this12.colors[j]\n            };\n          }); // TODO: upside-down tooltips for negative values?\n\n          this.tip.set_values(x, y, title, '', values);\n          this.tip.show_tip();\n          break;\n        }\n      }\n    } // API\n\n  }, {\n    key: 'show_sums',\n    value: function show_sums() {\n      var _this13 = this;\n\n      this.updating = true;\n      this.y_sums = new Array(this.x_axis_positions.length).fill(0);\n      this.y.map(function (d) {\n        d.values.map(function (value, i) {\n          _this13.y_sums[i] += value;\n        });\n      }); // Remake y axis, animate\n\n      this.update_values(); // Then make sum units, don't animate\n\n      this.sum_units = [];\n      this.make_new_units_for_dataset(this.x_axis_positions, this.y_sums.map(function (val) {\n        return float_2(_this13.zero_line - val * _this13.multiplier);\n      }), 'light-grey', 0, 1, this.sum_group, this.sum_units); // this.make_path && this.make_path(d, i, old_x, old_y, d.color || this.colors[i]);\n\n      this.updating = false;\n    }\n  }, {\n    key: 'hide_sums',\n    value: function hide_sums() {\n      if (this.updating) return;\n      this.y_sums = [];\n      this.sum_group.textContent = '';\n      this.sum_units = [];\n      this.update_values();\n    }\n  }, {\n    key: 'show_averages',\n    value: function show_averages() {\n      var _this14 = this;\n\n      this.old_specific_values = this.specific_values.slice();\n      this.y.map(function (d, i) {\n        var sum = 0;\n        d.values.map(function (e) {\n          sum += e;\n        });\n        var average = sum / d.values.length;\n\n        _this14.specific_values.push({\n          title: \"AVG\" + \" \" + (i + 1),\n          line_type: \"dashed\",\n          value: average,\n          auto: 1\n        });\n      });\n      this.update_values();\n    }\n  }, {\n    key: 'hide_averages',\n    value: function hide_averages() {\n      var _this15 = this;\n\n      this.old_specific_values = this.specific_values.slice();\n      var indices_to_remove = [];\n      this.specific_values.map(function (d, i) {\n        if (d.auto) indices_to_remove.unshift(i);\n      });\n      indices_to_remove.map(function (index) {\n        _this15.specific_values.splice(index, 1);\n      });\n      this.update_values();\n    }\n  }, {\n    key: 'update_values',\n    value: function update_values(new_y, new_x) {\n      var _this16 = this;\n\n      if (!new_x) {\n        new_x = this.x;\n      }\n\n      this.elements_to_animate = [];\n      this.updating = true;\n      this.old_x_values = this.x.slice();\n      this.old_y_axis_tops = this.y.map(function (d) {\n        return d.y_tops.slice();\n      });\n      this.old_y_values = this.y.map(function (d) {\n        return d.values;\n      });\n      this.no_of_extra_pts = new_x.length - this.x.length; // Just update values prop, setup_x/y() will do the rest\n\n      if (new_y) this.y.map(function (d, i) {\n        d.values = new_y[i].values;\n      });\n      if (new_x) this.x = new_x;\n      this.setup_x();\n      this.setup_y(); // Animate only if positions have changed\n\n      if (!arrays_equal(this.x_old_axis_positions, this.x_axis_positions)) {\n        this.make_x_axis(true);\n        setTimeout(function () {\n          if (!_this16.updating) _this16.make_x_axis();\n        }, 350);\n      }\n\n      if (!arrays_equal(this.y_old_axis_values, this.y_axis_values) || this.old_specific_values && !arrays_equal(this.old_specific_values, this.specific_values)) {\n        this.make_y_axis(true);\n        setTimeout(function () {\n          if (!_this16.updating) {\n            _this16.make_y_axis();\n\n            _this16.make_y_specifics();\n          }\n        }, 350);\n      } // Change in data, so calculate dependencies\n\n\n      this.calc_y_dependencies();\n      this.animate_graphs(); // Trigger animation with the animatable elements in this.elements_to_animate\n\n      this.run_animation();\n      this.updating = false;\n    }\n  }, {\n    key: 'add_data_point',\n    value: function add_data_point(y_point, x_point) {\n      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.x.length;\n      var new_y = this.y.map(function (data_set) {\n        return {\n          values: data_set.values\n        };\n      });\n      new_y.map(function (d, i) {\n        d.values.splice(index, 0, y_point[i]);\n      });\n      var new_x = this.x.slice();\n      new_x.splice(index, 0, x_point);\n      this.update_values(new_y, new_x);\n    }\n  }, {\n    key: 'remove_data_point',\n    value: function remove_data_point() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.x.length - 1;\n      if (this.x.length < 3) return;\n      var new_y = this.y.map(function (data_set) {\n        return {\n          values: data_set.values\n        };\n      });\n      new_y.map(function (d) {\n        d.values.splice(index, 1);\n      });\n      var new_x = this.x.slice();\n      new_x.splice(index, 1);\n      this.update_values(new_y, new_x);\n    }\n  }, {\n    key: 'run_animation',\n    value: function run_animation() {\n      var _this17 = this;\n\n      var anim_svg = $.runSVGAnimation(this.svg, this.elements_to_animate);\n\n      if (this.svg.parentNode == this.chart_wrapper) {\n        this.chart_wrapper.removeChild(this.svg);\n        this.chart_wrapper.appendChild(anim_svg);\n      } // Replace the new svg (data has long been replaced)\n\n\n      setTimeout(function () {\n        if (anim_svg.parentNode == _this17.chart_wrapper) {\n          _this17.chart_wrapper.removeChild(anim_svg);\n\n          _this17.chart_wrapper.appendChild(_this17.svg);\n        }\n      }, 250);\n    }\n  }, {\n    key: 'animate_graphs',\n    value: function animate_graphs() {\n      var _this18 = this;\n\n      this.y.map(function (d, i) {\n        // Pre-prep, equilize no of positions between old and new\n        var _calc_old_and_new_pos = _this18.calc_old_and_new_postions(d, i),\n            _calc_old_and_new_pos2 = slicedToArray(_calc_old_and_new_pos, 4),\n            old_x = _calc_old_and_new_pos2[0],\n            old_y = _calc_old_and_new_pos2[1],\n            new_x = _calc_old_and_new_pos2[2],\n            new_y = _calc_old_and_new_pos2[3];\n\n        if (_this18.no_of_extra_pts >= 0) {\n          _this18.make_path && _this18.make_path(d, i, old_x, old_y, d.color || _this18.colors[i]);\n\n          _this18.make_new_units_for_dataset(old_x, old_y, d.color || _this18.colors[i], i, _this18.y.length);\n        }\n\n        d.path && _this18.animate_path(d, i, old_x, old_y, new_x, new_y);\n\n        _this18.animate_units(d, i, old_x, old_y, new_x, new_y);\n      }); // TODO: replace with real units\n\n      setTimeout(function () {\n        _this18.y.map(function (d, i) {\n          _this18.make_path && _this18.make_path(d, i, _this18.x_axis_positions, d.y_tops, d.color || _this18.colors[i]);\n\n          _this18.make_new_units(d, i);\n        });\n      }, 400);\n    }\n  }, {\n    key: 'animate_path',\n    value: function animate_path(d, i, old_x, old_y, new_x, new_y) {\n      // Animate path\n      var new_points_list = new_y.map(function (y, i) {\n        return new_x[i] + ',' + y;\n      });\n      var new_path_str = new_points_list.join(\"L\");\n      var path_args = [{\n        unit: d.path,\n        object: d,\n        key: 'path'\n      }, {\n        d: \"M\" + new_path_str\n      }, 350, \"easein\"];\n      this.elements_to_animate.push(path_args); // Animate region\n\n      if (d.region_path) {\n        var reg_start_pt = '0,' + this.zero_line + 'L';\n        var reg_end_pt = 'L' + this.width + ',' + this.zero_line;\n        var region_args = [{\n          unit: d.region_path,\n          object: d,\n          key: 'region_path'\n        }, {\n          d: \"M\" + reg_start_pt + new_path_str + reg_end_pt\n        }, 350, \"easein\"];\n        this.elements_to_animate.push(region_args);\n      }\n    }\n  }, {\n    key: 'animate_units',\n    value: function animate_units(d, index, old_x, old_y, new_x, new_y) {\n      var _this19 = this;\n\n      var type = this.unit_args.type;\n      d.svg_units.map(function (unit, i) {\n        if (new_x[i] === undefined || new_y[i] === undefined) return;\n\n        _this19.elements_to_animate.push(_this19.animate[type]({\n          unit: unit,\n          array: d.svg_units,\n          index: i\n        }, // unit, with info to replace where it came from in the data\n        new_x[i], new_y[i], index));\n      });\n    }\n  }, {\n    key: 'calc_old_and_new_postions',\n    value: function calc_old_and_new_postions(d, i) {\n      var old_x = this.x_old_axis_positions.slice();\n      var new_x = this.x_axis_positions.slice();\n      var old_y = this.old_y_axis_tops[i].slice();\n      var new_y = d.y_tops.slice();\n      var last_old_x_pos = old_x[old_x.length - 1];\n      var last_old_y_pos = old_y[old_y.length - 1];\n      var last_new_x_pos = new_x[new_x.length - 1];\n      var last_new_y_pos = new_y[new_y.length - 1];\n\n      if (this.no_of_extra_pts >= 0) {\n        // First substitute current path with a squiggled one (looking the same but\n        // having more points at end),\n        // then animate to stretch it later to new points\n        // (new points already have more points)\n        // Hence, the extra end points will correspond to current(old) positions\n        var filler_x = new Array(Math.abs(this.no_of_extra_pts)).fill(last_old_x_pos);\n        var filler_y = new Array(Math.abs(this.no_of_extra_pts)).fill(last_old_y_pos);\n        old_x = old_x.concat(filler_x);\n        old_y = old_y.concat(filler_y);\n      } else {\n        // Just modify the new points to have extra points\n        // with the same position at end\n        var _filler_x = new Array(Math.abs(this.no_of_extra_pts)).fill(last_new_x_pos);\n\n        var _filler_y = new Array(Math.abs(this.no_of_extra_pts)).fill(last_new_y_pos);\n\n        new_x = new_x.concat(_filler_x);\n        new_y = new_y.concat(_filler_y);\n      }\n\n      return [old_x, old_y, new_x, new_y];\n    }\n  }, {\n    key: 'make_anim_x_axis',\n    value: function make_anim_x_axis(height, text_start_at, axis_line_class) {\n      var _this20 = this; // Animate X AXIS to account for more or less axis lines\n\n\n      var old_pos = this.x_old_axis_positions;\n      var new_pos = this.x_axis_positions;\n      var old_vals = this.old_x_values;\n      var new_vals = this.x;\n      var last_line_pos = old_pos[old_pos.length - 1];\n\n      var add_and_animate_line = function add_and_animate_line(value, old_pos, new_pos) {\n        if (typeof new_pos === 'string') {\n          new_pos = parseInt(new_pos.substring(0, new_pos.length - 1));\n        }\n\n        var x_line = _this20.make_x_line(height, text_start_at, value, // new value\n        'x-value-text', axis_line_class, old_pos // old position\n        );\n\n        _this20.x_axis_group.appendChild(x_line);\n\n        _this20.elements_to_animate && _this20.elements_to_animate.push([{\n          unit: x_line,\n          array: [0],\n          index: 0\n        }, {\n          transform: new_pos + ', 0'\n        }, 350, \"easein\", \"translate\", {\n          transform: old_pos + ', 0'\n        }]);\n      };\n\n      this.x_axis_group.textContent = '';\n      this.make_new_axis_anim_lines(old_pos, new_pos, old_vals, new_vals, last_line_pos, add_and_animate_line);\n    }\n  }, {\n    key: 'make_anim_y_axis',\n    value: function make_anim_y_axis() {\n      var _this21 = this; // Animate Y AXIS to account for more or less axis lines\n\n\n      var old_pos = this.y_old_axis_values.map(function (value) {\n        return _this21.zero_line - value * _this21.multiplier;\n      });\n      var new_pos = this.y_axis_values.map(function (value) {\n        return _this21.zero_line - value * _this21.multiplier;\n      });\n      var old_vals = this.y_old_axis_values;\n      var new_vals = this.y_axis_values;\n      var last_line_pos = old_pos[old_pos.length - 1];\n      this.y_axis_group.textContent = '';\n      this.make_new_axis_anim_lines(old_pos, new_pos, old_vals, new_vals, last_line_pos, this.add_and_animate_y_line.bind(this), this.y_axis_group);\n    }\n  }, {\n    key: 'make_anim_y_specifics',\n    value: function make_anim_y_specifics() {\n      var _this22 = this;\n\n      this.specific_y_group.textContent = '';\n      this.specific_values.map(function (d) {\n        _this22.add_and_animate_y_line(d.title, _this22.old_zero_line - d.value * _this22.old_multiplier, _this22.zero_line - d.value * _this22.multiplier, 0, _this22.specific_y_group, d.line_type, true);\n      });\n    }\n  }, {\n    key: 'make_new_axis_anim_lines',\n    value: function make_new_axis_anim_lines(old_pos, new_pos, old_vals, new_vals, last_line_pos, add_and_animate_line, group) {\n      var superimposed_positions = void 0,\n          superimposed_values = void 0;\n      var no_of_extras = new_vals.length - old_vals.length;\n\n      if (no_of_extras > 0) {\n        // More axis are needed\n        // First make only the superimposed (same position) ones\n        // Add in the extras at the end later\n        superimposed_positions = new_pos.slice(0, old_pos.length);\n        superimposed_values = new_vals.slice(0, old_vals.length);\n      } else {\n        // Axis have to be reduced\n        // Fake it by moving all current extra axis to the last position\n        // You'll need filler positions and values in the new arrays\n        var filler_vals = new Array(Math.abs(no_of_extras)).fill(\"\");\n        superimposed_values = new_vals.concat(filler_vals);\n        var filler_pos = new Array(Math.abs(no_of_extras)).fill(last_line_pos + \"F\");\n        superimposed_positions = new_pos.concat(filler_pos);\n      }\n\n      superimposed_values.map(function (value, i) {\n        add_and_animate_line(value, old_pos[i], superimposed_positions[i], i, group);\n      });\n\n      if (no_of_extras > 0) {\n        // Add in extra axis in the end\n        // and then animate to new positions\n        var extra_values = new_vals.slice(old_vals.length);\n        var extra_positions = new_pos.slice(old_pos.length);\n        extra_values.map(function (value, i) {\n          add_and_animate_line(value, last_line_pos, extra_positions[i], i, group);\n        });\n      }\n    }\n  }, {\n    key: 'make_x_line',\n    value: function make_x_line(height, text_start_at, point, label_class, axis_line_class, x_pos) {\n      var line = $.createSVG('line', {\n        x1: 0,\n        x2: 0,\n        y1: 0,\n        y2: height\n      });\n      var text = $.createSVG('text', {\n        className: label_class,\n        x: 0,\n        y: text_start_at,\n        dy: '.71em',\n        innerHTML: point\n      });\n      var x_level = $.createSVG('g', {\n        className: 'tick ' + axis_line_class,\n        transform: 'translate(' + x_pos + ', 0)'\n      });\n      x_level.appendChild(line);\n      x_level.appendChild(text);\n      return x_level;\n    }\n  }, {\n    key: 'make_y_line',\n    value: function make_y_line(start_at, width, text_end_at, point, label_class, axis_line_class, y_pos) {\n      var darker = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n      var line_type = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : \"\";\n      var line = $.createSVG('line', {\n        className: line_type === \"dashed\" ? \"dashed\" : \"\",\n        x1: start_at,\n        x2: width,\n        y1: 0,\n        y2: 0\n      });\n      var text = $.createSVG('text', {\n        className: label_class,\n        x: text_end_at,\n        y: 0,\n        dy: '.32em',\n        innerHTML: point + \"\"\n      });\n      var y_level = $.createSVG('g', {\n        className: 'tick ' + axis_line_class,\n        transform: 'translate(0, ' + y_pos + ')',\n        'stroke-opacity': 1\n      });\n\n      if (darker) {\n        line.style.stroke = \"rgba(27, 31, 35, 0.6)\";\n      }\n\n      y_level.appendChild(line);\n      y_level.appendChild(text);\n      return y_level;\n    }\n  }, {\n    key: 'add_and_animate_y_line',\n    value: function add_and_animate_y_line(value, old_pos, new_pos, i, group, type) {\n      var specific = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n      var filler = false;\n\n      if (typeof new_pos === 'string') {\n        new_pos = parseInt(new_pos.substring(0, new_pos.length - 1));\n        filler = true;\n      }\n\n      var new_props = {\n        transform: '0, ' + new_pos\n      };\n      var old_props = {\n        transform: '0, ' + old_pos\n      };\n\n      if (filler) {\n        new_props['stroke-opacity'] = 0; // old_props['stroke-opacity'] = 1;\n      }\n\n      var _get_y_axis_line_prop3 = this.get_y_axis_line_props(specific),\n          _get_y_axis_line_prop4 = slicedToArray(_get_y_axis_line_prop3, 4),\n          width = _get_y_axis_line_prop4[0],\n          text_end_at = _get_y_axis_line_prop4[1],\n          axis_line_class = _get_y_axis_line_prop4[2],\n          start_at = _get_y_axis_line_prop4[3];\n\n      var axis_label_class = !specific ? 'y-value-text' : 'specific-value';\n      value = !specific ? value : (value + \"\").toUpperCase();\n      var y_line = this.make_y_line(start_at, width, text_end_at, value, axis_label_class, axis_line_class, old_pos, // old position\n      value === 0 && i !== 0, // Non-first Zero line\n      type);\n      group.appendChild(y_line);\n      this.elements_to_animate && this.elements_to_animate.push([{\n        unit: y_line,\n        array: [0],\n        index: 0\n      }, new_props, 350, \"easein\", \"translate\", old_props]);\n    }\n  }, {\n    key: 'get_y_axis_points',\n    value: function get_y_axis_points(array) {\n      var _this23 = this; //*** Where the magic happens ***\n      // Calculates best-fit y intervals from given values\n      // and returns the interval array\n      // TODO: Fractions\n\n\n      var max_bound = void 0,\n          min_bound = void 0,\n          pos_no_of_parts = void 0,\n          neg_no_of_parts = void 0,\n          part_size = void 0; // eslint-disable-line no-unused-vars\n      // Critical values\n\n      var max_val = parseInt(Math.max.apply(Math, toConsumableArray(array)));\n      var min_val = parseInt(Math.min.apply(Math, toConsumableArray(array)));\n\n      if (min_val >= 0) {\n        min_val = 0;\n      }\n\n      var get_params = function get_params(value1, value2) {\n        var bound1 = void 0,\n            bound2 = void 0,\n            no_of_parts_1 = void 0,\n            no_of_parts_2 = void 0,\n            interval_size = void 0;\n\n        if ((value1 + \"\").length <= 1) {\n          bound1 = 10;\n          no_of_parts_1 = 5;\n        } else {\n          var _calc_upper_bound_and = _this23.calc_upper_bound_and_no_of_parts(value1);\n\n          var _calc_upper_bound_and2 = slicedToArray(_calc_upper_bound_and, 2);\n\n          bound1 = _calc_upper_bound_and2[0];\n          no_of_parts_1 = _calc_upper_bound_and2[1];\n        }\n\n        interval_size = bound1 / no_of_parts_1;\n        no_of_parts_2 = _this23.calc_no_of_parts(value2, interval_size);\n        bound2 = no_of_parts_2 * interval_size;\n        return [bound1, bound2, no_of_parts_1, no_of_parts_2, interval_size];\n      };\n\n      var abs_min_val = min_val * -1;\n\n      if (abs_min_val <= max_val) {\n        var _get_params = get_params(max_val, abs_min_val); // Get the positive region intervals\n        // then calc negative ones accordingly\n\n\n        var _get_params2 = slicedToArray(_get_params, 5);\n\n        min_bound = _get_params2[1];\n        pos_no_of_parts = _get_params2[2];\n        neg_no_of_parts = _get_params2[3];\n        part_size = _get_params2[4];\n\n        if (abs_min_val === 0) {\n          min_bound = 0;\n          neg_no_of_parts = 0;\n        }\n      } else {\n        var _get_params3 = get_params(abs_min_val, max_val); // Get the negative region here first\n\n\n        var _get_params4 = slicedToArray(_get_params3, 5);\n\n        min_bound = _get_params4[0];\n        neg_no_of_parts = _get_params4[2];\n        pos_no_of_parts = _get_params4[3];\n        part_size = _get_params4[4];\n      } // Make both region parts even\n\n\n      if (pos_no_of_parts % 2 !== 0 && neg_no_of_parts > 0) pos_no_of_parts++;\n\n      if (neg_no_of_parts % 2 !== 0) {\n        // every increase in no_of_parts entails an increase in corresponding bound\n        // except here, it happens implicitly after every calc_no_of_parts() call\n        neg_no_of_parts++;\n        min_bound += part_size;\n      }\n\n      var no_of_parts = pos_no_of_parts + neg_no_of_parts;\n\n      if (no_of_parts > 5) {\n        no_of_parts /= 2;\n        part_size *= 2;\n        pos_no_of_parts /= 2;\n      }\n\n      if (max_val < (pos_no_of_parts - 1) * part_size) {\n        no_of_parts--;\n      }\n\n      return this.get_intervals(-1 * min_bound, part_size, no_of_parts);\n    }\n  }, {\n    key: 'get_intervals',\n    value: function get_intervals(start, interval_size, count) {\n      var intervals = [];\n\n      for (var i = 0; i <= count; i++) {\n        intervals.push(start);\n        start += interval_size;\n      }\n\n      return intervals;\n    }\n  }, {\n    key: 'calc_upper_bound_and_no_of_parts',\n    value: function calc_upper_bound_and_no_of_parts(max_val) {\n      // Given a positive value, calculates a nice-number upper bound\n      // and a consequent optimal number of parts\n      var part_size = Math.pow(10, (max_val + \"\").length - 1);\n      var no_of_parts = this.calc_no_of_parts(max_val, part_size); // Use it to get a nice even upper bound\n\n      var upper_bound = part_size * no_of_parts;\n      return [upper_bound, no_of_parts];\n    }\n  }, {\n    key: 'calc_no_of_parts',\n    value: function calc_no_of_parts(value, divisor) {\n      // value should be a positive number, divisor should be greater than 0\n      // returns an even no of parts\n      var no_of_parts = Math.ceil(value / divisor);\n      if (no_of_parts % 2 !== 0) no_of_parts++; // Make it an even number\n\n      return no_of_parts;\n    }\n  }, {\n    key: 'get_optimal_no_of_parts',\n    value: function get_optimal_no_of_parts(no_of_parts) {\n      // aka Divide by 2 if too large\n      return no_of_parts < 5 ? no_of_parts : no_of_parts / 2;\n    }\n  }, {\n    key: 'set_avg_unit_width_and_x_offset',\n    value: function set_avg_unit_width_and_x_offset() {\n      // Set the ... you get it\n      this.avg_unit_width = this.width / (this.x.length - 1);\n      this.x_offset = 0;\n    }\n  }, {\n    key: 'get_all_y_values',\n    value: function get_all_y_values() {\n      var all_values = []; // Add in all the y values in the datasets\n\n      this.y.map(function (d) {\n        all_values = all_values.concat(d.values);\n      }); // Add in all the specific values\n\n      return all_values.concat(this.specific_values.map(function (d) {\n        return d.value;\n      }));\n    }\n  }, {\n    key: 'calc_y_dependencies',\n    value: function calc_y_dependencies() {\n      var _this24 = this;\n\n      this.y_min_tops = new Array(this.x_axis_positions.length).fill(9999);\n      this.y.map(function (d) {\n        d.y_tops = d.values.map(function (val) {\n          return float_2(_this24.zero_line - val * _this24.multiplier);\n        });\n        d.y_tops.map(function (y_top, i) {\n          if (y_top < _this24.y_min_tops[i]) {\n            _this24.y_min_tops[i] = y_top;\n          }\n        });\n      }); // this.chart_wrapper.removeChild(this.tip.container);\n      // this.make_tooltip();\n    }\n  }, {\n    key: 'get_bar_height_and_y_attr',\n    value: function get_bar_height_and_y_attr(y_top) {\n      var height = void 0,\n          y = void 0;\n\n      if (y_top <= this.zero_line) {\n        height = this.zero_line - y_top;\n        y = y_top; // In case of invisible bars\n\n        if (height === 0) {\n          height = this.height * 0.01;\n          y -= height;\n        }\n      } else {\n        height = y_top - this.zero_line;\n        y = this.zero_line; // In case of invisible bars\n\n        if (height === 0) {\n          height = this.height * 0.01;\n        }\n      }\n\n      return [height, y];\n    }\n  }, {\n    key: 'setup_utils',\n    value: function setup_utils() {\n      var _this25 = this;\n\n      this.draw = {\n        'bar': function bar(x, y_top, args, color, index, dataset_index, no_of_datasets) {\n          var total_width = _this25.avg_unit_width - args.space_width;\n          var start_x = x - total_width / 2;\n          var width = total_width / no_of_datasets;\n          var current_x = start_x + width * dataset_index;\n\n          var _get_bar_height_and_y = _this25.get_bar_height_and_y_attr(y_top),\n              _get_bar_height_and_y2 = slicedToArray(_get_bar_height_and_y, 2),\n              height = _get_bar_height_and_y2[0],\n              y = _get_bar_height_and_y2[1];\n\n          return $.createSVG('rect', {\n            className: 'bar mini fill ' + color,\n            'data-point-index': index,\n            x: current_x,\n            y: y,\n            width: width,\n            height: height\n          });\n        },\n        'dot': function dot(x, y, args, color, index) {\n          return $.createSVG('circle', {\n            className: 'fill ' + color,\n            'data-point-index': index,\n            cx: x,\n            cy: y,\n            r: args.radius\n          });\n        }\n      };\n      this.animate = {\n        'bar': function bar(bar_obj, x, y_top, index) {\n          var start = x - _this25.avg_unit_width / 4;\n          var width = _this25.avg_unit_width / 2 / _this25.y.length;\n\n          var _get_bar_height_and_y3 = _this25.get_bar_height_and_y_attr(y_top),\n              _get_bar_height_and_y4 = slicedToArray(_get_bar_height_and_y3, 2),\n              height = _get_bar_height_and_y4[0],\n              y = _get_bar_height_and_y4[1];\n\n          x = start + width * index;\n          return [bar_obj, {\n            width: width,\n            height: height,\n            x: x,\n            y: y\n          }, 350, \"easein\"]; // bar.animate({height: args.new_height, y: y_top}, 350, mina.easein);\n        },\n        'dot': function dot(dot_obj, x, y_top) {\n          return [dot_obj, {\n            cx: x,\n            cy: y_top\n          }, 350, \"easein\"]; // dot.animate({cy: y_top}, 350, mina.easein);\n        }\n      };\n    }\n  }]);\n  return AxisChart;\n}(BaseChart);\n\nvar BarChart = function (_AxisChart) {\n  inherits(BarChart, _AxisChart);\n\n  function BarChart(args) {\n    classCallCheck(this, BarChart);\n\n    var _this = possibleConstructorReturn(this, (BarChart.__proto__ || Object.getPrototypeOf(BarChart)).call(this, args));\n\n    _this.type = 'bar';\n    _this.x_axis_mode = args.x_axis_mode || 'tick';\n    _this.y_axis_mode = args.y_axis_mode || 'span';\n\n    _this.setup();\n\n    return _this;\n  }\n\n  createClass(BarChart, [{\n    key: 'setup_values',\n    value: function setup_values() {\n      get(BarChart.prototype.__proto__ || Object.getPrototypeOf(BarChart.prototype), 'setup_values', this).call(this);\n      this.x_offset = this.avg_unit_width;\n      this.unit_args = {\n        type: 'bar',\n        args: {\n          space_width: this.avg_unit_width / 2\n        }\n      };\n    }\n  }, {\n    key: 'make_overlay',\n    value: function make_overlay() {\n      // Just make one out of the first element\n      var index = this.x.length - 1;\n      var unit = this.y[0].svg_units[index];\n      this.update_current_data_point(index);\n\n      if (this.overlay) {\n        this.overlay.parentNode.removeChild(this.overlay);\n      }\n\n      this.overlay = unit.cloneNode();\n      this.overlay.style.fill = '#000000';\n      this.overlay.style.opacity = '0.4';\n      this.draw_area.appendChild(this.overlay);\n    }\n  }, {\n    key: 'bind_overlay',\n    value: function bind_overlay() {\n      var _this2 = this; // on event, update overlay\n\n\n      this.parent.addEventListener('data-select', function (e) {\n        _this2.update_overlay(e.svg_unit);\n      });\n    }\n  }, {\n    key: 'bind_units',\n    value: function bind_units(units_array) {\n      var _this3 = this;\n\n      units_array.map(function (unit) {\n        unit.addEventListener('click', function () {\n          var index = unit.getAttribute('data-point-index');\n\n          _this3.update_current_data_point(index);\n        });\n      });\n    }\n  }, {\n    key: 'update_overlay',\n    value: function update_overlay(unit) {\n      var _this4 = this;\n\n      var attributes = [];\n      Object.keys(unit.attributes).map(function (index) {\n        attributes.push(unit.attributes[index]);\n      });\n      attributes.filter(function (attr) {\n        return attr.specified;\n      }).map(function (attr) {\n        _this4.overlay.setAttribute(attr.name, attr.nodeValue);\n      });\n    }\n  }, {\n    key: 'on_left_arrow',\n    value: function on_left_arrow() {\n      this.update_current_data_point(this.current_index - 1);\n    }\n  }, {\n    key: 'on_right_arrow',\n    value: function on_right_arrow() {\n      this.update_current_data_point(this.current_index + 1);\n    }\n  }, {\n    key: 'set_avg_unit_width_and_x_offset',\n    value: function set_avg_unit_width_and_x_offset() {\n      this.avg_unit_width = this.width / (this.x.length + 1);\n      this.x_offset = this.avg_unit_width;\n    }\n  }]);\n  return BarChart;\n}(AxisChart);\n\nvar LineChart = function (_AxisChart) {\n  inherits(LineChart, _AxisChart);\n\n  function LineChart(args) {\n    classCallCheck(this, LineChart);\n\n    var _this = possibleConstructorReturn(this, (LineChart.__proto__ || Object.getPrototypeOf(LineChart)).call(this, args));\n\n    _this.x_axis_mode = args.x_axis_mode || 'span';\n    _this.y_axis_mode = args.y_axis_mode || 'span';\n\n    if (args.hasOwnProperty('show_dots')) {\n      _this.show_dots = args.show_dots;\n    } else {\n      _this.show_dots = 1;\n    }\n\n    _this.region_fill = args.region_fill;\n\n    if (Object.getPrototypeOf(_this) !== LineChart.prototype) {\n      return possibleConstructorReturn(_this);\n    }\n\n    _this.dot_radius = args.dot_radius || 4;\n    _this.heatline = args.heatline;\n    _this.type = 'line';\n\n    _this.setup();\n\n    return _this;\n  }\n\n  createClass(LineChart, [{\n    key: 'setup_graph_components',\n    value: function setup_graph_components() {\n      this.setup_path_groups();\n      get(LineChart.prototype.__proto__ || Object.getPrototypeOf(LineChart.prototype), 'setup_graph_components', this).call(this);\n    }\n  }, {\n    key: 'setup_path_groups',\n    value: function setup_path_groups() {\n      var _this2 = this;\n\n      this.paths_groups = [];\n      this.y.map(function (d, i) {\n        _this2.paths_groups[i] = $.createSVG('g', {\n          className: 'path-group path-group-' + i,\n          inside: _this2.draw_area\n        });\n      });\n    }\n  }, {\n    key: 'setup_values',\n    value: function setup_values() {\n      get(LineChart.prototype.__proto__ || Object.getPrototypeOf(LineChart.prototype), 'setup_values', this).call(this);\n      this.unit_args = {\n        type: 'dot',\n        args: {\n          radius: this.dot_radius\n        }\n      };\n    }\n  }, {\n    key: 'make_new_units_for_dataset',\n    value: function make_new_units_for_dataset(x_values, y_values, color, dataset_index, no_of_datasets, units_group, units_array, unit) {\n      if (this.show_dots) {\n        get(LineChart.prototype.__proto__ || Object.getPrototypeOf(LineChart.prototype), 'make_new_units_for_dataset', this).call(this, x_values, y_values, color, dataset_index, no_of_datasets, units_group, units_array, unit);\n      }\n    }\n  }, {\n    key: 'make_paths',\n    value: function make_paths() {\n      var _this3 = this;\n\n      this.y.map(function (d, i) {\n        _this3.make_path(d, i, _this3.x_axis_positions, d.y_tops, d.color || _this3.colors[i]);\n      });\n    }\n  }, {\n    key: 'make_path',\n    value: function make_path(d, i, x_positions, y_positions, color) {\n      var points_list = y_positions.map(function (y, i) {\n        return x_positions[i] + ',' + y;\n      });\n      var points_str = points_list.join(\"L\");\n      this.paths_groups[i].textContent = '';\n      d.path = $.createSVG('path', {\n        inside: this.paths_groups[i],\n        className: 'stroke ' + color,\n        d: \"M\" + points_str\n      });\n\n      if (this.heatline) {\n        var gradient_id = this.make_gradient(color);\n        d.path.style.stroke = 'url(#' + gradient_id + ')';\n      }\n\n      if (this.region_fill) {\n        this.fill_region_for_dataset(d, i, color, points_str);\n      }\n    }\n  }, {\n    key: 'fill_region_for_dataset',\n    value: function fill_region_for_dataset(d, i, color, points_str) {\n      var gradient_id = this.make_gradient(color, true);\n      d.region_path = $.createSVG('path', {\n        inside: this.paths_groups[i],\n        className: 'region-fill',\n        d: \"M\" + ('0,' + this.zero_line + 'L') + points_str + ('L' + this.width + ',' + this.zero_line)\n      });\n      d.region_path.style.stroke = \"none\";\n      d.region_path.style.fill = 'url(#' + gradient_id + ')';\n    }\n  }, {\n    key: 'make_gradient',\n    value: function make_gradient(color) {\n      var lighter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var gradient_id = 'path-fill-gradient' + '-' + color;\n      var gradient_def = $.createSVG('linearGradient', {\n        inside: this.svg_defs,\n        id: gradient_id,\n        x1: 0,\n        x2: 0,\n        y1: 0,\n        y2: 1\n      });\n\n      var set_gradient_stop = function set_gradient_stop(grad_elem, offset, color, opacity) {\n        $.createSVG('stop', {\n          'className': 'stop-color ' + color,\n          'inside': grad_elem,\n          'offset': offset,\n          'stop-opacity': opacity\n        });\n      };\n\n      var opacities = [1, 0.6, 0.2];\n\n      if (lighter) {\n        opacities = [0.4, 0.2, 0];\n      }\n\n      set_gradient_stop(gradient_def, \"0%\", color, opacities[0]);\n      set_gradient_stop(gradient_def, \"50%\", color, opacities[1]);\n      set_gradient_stop(gradient_def, \"100%\", color, opacities[2]);\n      return gradient_id;\n    }\n  }]);\n  return LineChart;\n}(AxisChart);\n\nvar ScatterChart = function (_LineChart) {\n  inherits(ScatterChart, _LineChart);\n\n  function ScatterChart(args) {\n    classCallCheck(this, ScatterChart);\n\n    var _this = possibleConstructorReturn(this, (ScatterChart.__proto__ || Object.getPrototypeOf(ScatterChart)).call(this, args));\n\n    _this.type = 'scatter';\n\n    if (!args.dot_radius) {\n      _this.dot_radius = 8;\n    } else {\n      _this.dot_radius = args.dot_radius;\n    }\n\n    _this.setup();\n\n    return _this;\n  }\n\n  createClass(ScatterChart, [{\n    key: 'setup_graph_components',\n    value: function setup_graph_components() {\n      this.setup_path_groups();\n      get(ScatterChart.prototype.__proto__ || Object.getPrototypeOf(ScatterChart.prototype), 'setup_graph_components', this).call(this);\n    }\n  }, {\n    key: 'setup_path_groups',\n    value: function setup_path_groups() {}\n  }, {\n    key: 'setup_values',\n    value: function setup_values() {\n      get(ScatterChart.prototype.__proto__ || Object.getPrototypeOf(ScatterChart.prototype), 'setup_values', this).call(this);\n      this.unit_args = {\n        type: 'dot',\n        args: {\n          radius: this.dot_radius\n        }\n      };\n    }\n  }, {\n    key: 'make_paths',\n    value: function make_paths() {}\n  }, {\n    key: 'make_path',\n    value: function make_path() {}\n  }]);\n  return ScatterChart;\n}(LineChart);\n\nvar PercentageChart = function (_BaseChart) {\n  inherits(PercentageChart, _BaseChart);\n\n  function PercentageChart(args) {\n    classCallCheck(this, PercentageChart);\n\n    var _this = possibleConstructorReturn(this, (PercentageChart.__proto__ || Object.getPrototypeOf(PercentageChart)).call(this, args));\n\n    _this.type = 'percentage';\n    _this.get_y_label = _this.format_lambdas.y_label;\n    _this.get_x_tooltip = _this.format_lambdas.x_tooltip;\n    _this.get_y_tooltip = _this.format_lambdas.y_tooltip;\n    _this.max_slices = 10;\n    _this.max_legend_points = 6;\n    _this.colors = args.colors;\n\n    if (!_this.colors || _this.colors.length < _this.data.labels.length) {\n      _this.colors = ['light-blue', 'blue', 'violet', 'red', 'orange', 'yellow', 'green', 'light-green', 'purple', 'magenta'];\n    }\n\n    _this.setup();\n\n    return _this;\n  }\n\n  createClass(PercentageChart, [{\n    key: 'make_chart_area',\n    value: function make_chart_area() {\n      this.chart_wrapper.className += ' ' + 'graph-focus-margin';\n      this.chart_wrapper.style.marginTop = '45px';\n      this.stats_wrapper.className += ' ' + 'graph-focus-margin';\n      this.stats_wrapper.style.marginBottom = '30px';\n      this.stats_wrapper.style.paddingTop = '0px';\n    }\n  }, {\n    key: 'make_draw_area',\n    value: function make_draw_area() {\n      this.chart_div = $.create('div', {\n        className: 'div',\n        inside: this.chart_wrapper\n      });\n      this.chart = $.create('div', {\n        className: 'progress-chart',\n        inside: this.chart_div\n      });\n    }\n  }, {\n    key: 'setup_components',\n    value: function setup_components() {\n      this.percentage_bar = $.create('div', {\n        className: 'progress',\n        inside: this.chart\n      });\n    }\n  }, {\n    key: 'setup_values',\n    value: function setup_values() {\n      var _this2 = this;\n\n      this.slice_totals = [];\n      var all_totals = this.data.labels.map(function (d, i) {\n        var total = 0;\n\n        _this2.data.datasets.map(function (e) {\n          total += e.values[i];\n        });\n\n        return [total, d];\n      }).filter(function (d) {\n        return d[0] > 0;\n      }); // keep only positive results\n\n      var totals = all_totals;\n\n      if (all_totals.length > this.max_slices) {\n        all_totals.sort(function (a, b) {\n          return b[0] - a[0];\n        });\n        totals = all_totals.slice(0, this.max_slices - 1);\n        var others = all_totals.slice(this.max_slices - 1);\n        var sum_of_others = 0;\n        others.map(function (d) {\n          sum_of_others += d[0];\n        });\n        totals.push([sum_of_others, 'Rest']);\n        this.colors[this.max_slices - 1] = 'grey';\n      }\n\n      this.labels = [];\n      totals.map(function (d) {\n        _this2.slice_totals.push(d[0]);\n\n        _this2.labels.push(d[1]);\n      });\n      this.legend_totals = this.slice_totals.slice(0, this.max_legend_points);\n    }\n  }, {\n    key: 'setup_utils',\n    value: function setup_utils() {}\n  }, {\n    key: 'make_graph_components',\n    value: function make_graph_components() {\n      var _this3 = this;\n\n      this.grand_total = this.slice_totals.reduce(function (a, b) {\n        return a + b;\n      }, 0);\n      this.slices = [];\n      this.slice_totals.map(function (total, i) {\n        var slice = $.create('div', {\n          className: 'progress-bar background ' + _this3.colors[i],\n          inside: _this3.percentage_bar,\n          styles: {\n            width: total * 100 / _this3.grand_total + \"%\"\n          }\n        });\n\n        _this3.slices.push(slice);\n      });\n    }\n  }, {\n    key: 'bind_tooltip',\n    value: function bind_tooltip() {\n      var _this4 = this;\n\n      this.slices.map(function (slice, i) {\n        slice.addEventListener('mouseenter', function () {\n          var g_off = $.offset(_this4.chart_wrapper),\n              p_off = $.offset(slice);\n          var x = p_off.left - g_off.left + slice.offsetWidth / 2;\n          var y = p_off.top - g_off.top - 6;\n          var title = (_this4.formatted_labels && _this4.formatted_labels.length > 0 ? _this4.formatted_labels[i] : _this4.labels[i]) + ': ';\n\n          var percent = (_this4.slice_totals[i] * 100 / _this4.grand_total).toFixed(1);\n\n          _this4.tip.set_values(x, y, title, percent + \"%\");\n\n          _this4.tip.show_tip();\n        });\n      });\n    }\n  }, {\n    key: 'show_summary',\n    value: function show_summary() {\n      var _this5 = this;\n\n      var x_values = this.formatted_labels && this.formatted_labels.length > 0 ? this.formatted_labels : this.labels;\n      this.legend_totals.map(function (d, i) {\n        if (d) {\n          var stats = $.create('div', {\n            className: 'stats',\n            inside: _this5.stats_wrapper\n          });\n          stats.innerHTML = '<span class=\"indicator ' + _this5.colors[i] + '\">\\n\\t\\t\\t\\t\\t<span class=\"text-muted\">' + x_values[i] + ':</span>\\n\\t\\t\\t\\t\\t' + d + '\\n\\t\\t\\t\\t</span>';\n        }\n      });\n    }\n  }]);\n  return PercentageChart;\n}(BaseChart);\n\nvar ANGLE_RATIO = Math.PI / 180;\nvar FULL_ANGLE = 360;\n\nvar PieChart = function (_BaseChart) {\n  inherits(PieChart, _BaseChart);\n\n  function PieChart(args) {\n    classCallCheck(this, PieChart);\n\n    var _this = possibleConstructorReturn(this, (PieChart.__proto__ || Object.getPrototypeOf(PieChart)).call(this, args));\n\n    _this.type = 'pie';\n    _this.get_y_label = _this.format_lambdas.y_label;\n    _this.get_x_tooltip = _this.format_lambdas.x_tooltip;\n    _this.get_y_tooltip = _this.format_lambdas.y_tooltip;\n    _this.elements_to_animate = null;\n    _this.hoverRadio = args.hoverRadio || 0.1;\n    _this.max_slices = 10;\n    _this.max_legend_points = 6;\n    _this.isAnimate = false;\n    _this.colors = args.colors;\n    _this.startAngle = args.startAngle || 0;\n    _this.clockWise = args.clockWise || false;\n\n    if (!_this.colors || _this.colors.length < _this.data.labels.length) {\n      _this.colors = ['#7cd6fd', '#5e64ff', '#743ee2', '#ff5858', '#ffa00a', '#FEEF72', '#28a745', '#98d85b', '#b554ff', '#ffa3ef'];\n    }\n\n    _this.mouseMove = _this.mouseMove.bind(_this);\n    _this.mouseLeave = _this.mouseLeave.bind(_this);\n\n    _this.setup();\n\n    return _this;\n  }\n\n  createClass(PieChart, [{\n    key: 'setup_values',\n    value: function setup_values() {\n      var _this2 = this;\n\n      this.centerX = this.width / 2;\n      this.centerY = this.height / 2;\n      this.radius = this.height > this.width ? this.centerX : this.centerY;\n      this.slice_totals = [];\n      var all_totals = this.data.labels.map(function (d, i) {\n        var total = 0;\n\n        _this2.data.datasets.map(function (e) {\n          total += e.values[i];\n        });\n\n        return [total, d];\n      }).filter(function (d) {\n        return d[0] > 0;\n      }); // keep only positive results\n\n      var totals = all_totals;\n\n      if (all_totals.length > this.max_slices) {\n        all_totals.sort(function (a, b) {\n          return b[0] - a[0];\n        });\n        totals = all_totals.slice(0, this.max_slices - 1);\n        var others = all_totals.slice(this.max_slices - 1);\n        var sum_of_others = 0;\n        others.map(function (d) {\n          sum_of_others += d[0];\n        });\n        totals.push([sum_of_others, 'Rest']);\n        this.colors[this.max_slices - 1] = 'grey';\n      }\n\n      this.labels = [];\n      totals.map(function (d) {\n        _this2.slice_totals.push(d[0]);\n\n        _this2.labels.push(d[1]);\n      });\n      this.legend_totals = this.slice_totals.slice(0, this.max_legend_points);\n    }\n  }, {\n    key: 'setup_utils',\n    value: function setup_utils() {}\n  }, {\n    key: 'makeArcPath',\n    value: function makeArcPath(startPosition, endPosition) {\n      var centerX = this.centerX,\n          centerY = this.centerY,\n          radius = this.radius,\n          clockWise = this.clockWise;\n      return 'M' + centerX + ' ' + centerY + ' L' + (centerX + startPosition.x) + ' ' + (centerY + startPosition.y) + ' A ' + radius + ' ' + radius + ' 0 0 ' + (clockWise ? 1 : 0) + ' ' + (centerX + endPosition.x) + ' ' + (centerY + endPosition.y) + ' z';\n    }\n  }, {\n    key: 'make_graph_components',\n    value: function make_graph_components(init) {\n      var _this3 = this;\n\n      var radius = this.radius,\n          clockWise = this.clockWise;\n      this.grand_total = this.slice_totals.reduce(function (a, b) {\n        return a + b;\n      }, 0);\n      var prevSlicesProperties = this.slicesProperties || [];\n      this.slices = [];\n      this.elements_to_animate = [];\n      this.slicesProperties = [];\n      var curAngle = 180 - this.startAngle;\n      this.slice_totals.map(function (total, i) {\n        var startAngle = curAngle;\n        var originDiffAngle = total / _this3.grand_total * FULL_ANGLE;\n        var diffAngle = clockWise ? -originDiffAngle : originDiffAngle;\n        var endAngle = curAngle = curAngle + diffAngle;\n        var startPosition = PieChart.getPositionByAngle(startAngle, radius);\n        var endPosition = PieChart.getPositionByAngle(endAngle, radius);\n        var prevProperty = init && prevSlicesProperties[i];\n        var curStart = void 0,\n            curEnd = void 0;\n\n        if (init) {\n          curStart = prevProperty ? prevProperty.startPosition : startPosition;\n          curEnd = prevProperty ? prevProperty.endPosition : startPosition;\n        } else {\n          curStart = startPosition;\n          curEnd = endPosition;\n        }\n\n        var curPath = _this3.makeArcPath(curStart, curEnd);\n\n        var slice = $.createSVG('path', {\n          inside: _this3.draw_area,\n          className: 'pie-path',\n          style: 'transition:transform .3s;',\n          d: curPath,\n          fill: _this3.colors[i]\n        });\n\n        _this3.slices.push(slice);\n\n        _this3.slicesProperties.push({\n          startPosition: startPosition,\n          endPosition: endPosition,\n          value: total,\n          total: _this3.grand_total,\n          startAngle: startAngle,\n          endAngle: endAngle,\n          angle: diffAngle\n        });\n\n        if (init) {\n          _this3.elements_to_animate.push([{\n            unit: slice,\n            array: _this3.slices,\n            index: _this3.slices.length - 1\n          }, {\n            d: _this3.makeArcPath(startPosition, endPosition)\n          }, 650, \"easein\", null, {\n            d: curPath\n          }]);\n        }\n      });\n\n      if (init) {\n        this.run_animation();\n      }\n    }\n  }, {\n    key: 'run_animation',\n    value: function run_animation() {\n      var _this4 = this; // if(this.isAnimate) return ;\n      // this.isAnimate = true;\n\n\n      if (!this.elements_to_animate || this.elements_to_animate.length === 0) return;\n      var anim_svg = $.runSVGAnimation(this.svg, this.elements_to_animate);\n\n      if (this.svg.parentNode == this.chart_wrapper) {\n        this.chart_wrapper.removeChild(this.svg);\n        this.chart_wrapper.appendChild(anim_svg);\n      } // Replace the new svg (data has long been replaced)\n\n\n      setTimeout(function () {\n        // this.isAnimate = false;\n        if (anim_svg.parentNode == _this4.chart_wrapper) {\n          _this4.chart_wrapper.removeChild(anim_svg);\n\n          _this4.chart_wrapper.appendChild(_this4.svg);\n        }\n      }, 650);\n    }\n  }, {\n    key: 'calTranslateByAngle',\n    value: function calTranslateByAngle(property) {\n      var radius = this.radius,\n          hoverRadio = this.hoverRadio;\n      var position = PieChart.getPositionByAngle(property.startAngle + property.angle / 2, radius);\n      return 'translate3d(' + position.x * hoverRadio + 'px,' + position.y * hoverRadio + 'px,0)';\n    }\n  }, {\n    key: 'hoverSlice',\n    value: function hoverSlice(path, i, flag, e) {\n      if (!path) return;\n\n      if (flag) {\n        $.transform(path, this.calTranslateByAngle(this.slicesProperties[i]));\n        path.setAttribute('fill', lightenDarkenColor(this.colors[i], 50));\n        var g_off = $.offset(this.svg);\n        var x = e.pageX - g_off.left + 10;\n        var y = e.pageY - g_off.top - 10;\n        var title = (this.formatted_labels && this.formatted_labels.length > 0 ? this.formatted_labels[i] : this.labels[i]) + ': ';\n        var percent = (this.slice_totals[i] * 100 / this.grand_total).toFixed(1);\n        this.tip.set_values(x, y, title, percent + \"%\");\n        this.tip.show_tip();\n      } else {\n        $.transform(path, 'translate3d(0,0,0)');\n        this.tip.hide_tip();\n        path.setAttribute('fill', this.colors[i]);\n      }\n    }\n  }, {\n    key: 'mouseMove',\n    value: function mouseMove(e) {\n      var target = e.target;\n      var prevIndex = this.curActiveSliceIndex;\n      var prevAcitve = this.curActiveSlice;\n\n      for (var i = 0; i < this.slices.length; i++) {\n        if (target === this.slices[i]) {\n          this.hoverSlice(prevAcitve, prevIndex, false);\n          this.curActiveSlice = target;\n          this.curActiveSliceIndex = i;\n          this.hoverSlice(target, i, true, e);\n          break;\n        }\n      }\n    }\n  }, {\n    key: 'mouseLeave',\n    value: function mouseLeave() {\n      this.hoverSlice(this.curActiveSlice, this.curActiveSliceIndex, false);\n    }\n  }, {\n    key: 'bind_tooltip',\n    value: function bind_tooltip() {\n      this.draw_area.addEventListener('mousemove', this.mouseMove);\n      this.draw_area.addEventListener('mouseleave', this.mouseLeave);\n    }\n  }, {\n    key: 'show_summary',\n    value: function show_summary() {\n      var _this5 = this;\n\n      var x_values = this.formatted_labels && this.formatted_labels.length > 0 ? this.formatted_labels : this.labels;\n      this.legend_totals.map(function (d, i) {\n        if (d) {\n          var stats = $.create('div', {\n            className: 'stats',\n            inside: _this5.stats_wrapper\n          });\n          stats.innerHTML = '<span class=\"indicator\">\\n\\t\\t\\t\\t\\t<i style=\"background-color:' + _this5.colors[i] + ';\"></i>\\n\\t\\t\\t\\t\\t<span class=\"text-muted\">' + x_values[i] + ':</span>\\n\\t\\t\\t\\t\\t' + d + '\\n\\t\\t\\t\\t</span>';\n        }\n      });\n    }\n  }], [{\n    key: 'getPositionByAngle',\n    value: function getPositionByAngle(angle, radius) {\n      return {\n        x: Math.sin(angle * ANGLE_RATIO) * radius,\n        y: Math.cos(angle * ANGLE_RATIO) * radius\n      };\n    }\n  }]);\n  return PieChart;\n}(BaseChart);\n\nvar Heatmap = function (_BaseChart) {\n  inherits(Heatmap, _BaseChart);\n\n  function Heatmap(_ref) {\n    var _ref$start = _ref.start,\n        start = _ref$start === undefined ? '' : _ref$start,\n        _ref$domain = _ref.domain,\n        domain = _ref$domain === undefined ? '' : _ref$domain,\n        _ref$subdomain = _ref.subdomain,\n        subdomain = _ref$subdomain === undefined ? '' : _ref$subdomain,\n        _ref$data = _ref.data,\n        data = _ref$data === undefined ? {} : _ref$data,\n        _ref$discrete_domains = _ref.discrete_domains,\n        discrete_domains = _ref$discrete_domains === undefined ? 0 : _ref$discrete_domains,\n        _ref$count_label = _ref.count_label,\n        count_label = _ref$count_label === undefined ? '' : _ref$count_label;\n    classCallCheck(this, Heatmap);\n\n    var _this = possibleConstructorReturn(this, (Heatmap.__proto__ || Object.getPrototypeOf(Heatmap)).call(this, arguments[0]));\n\n    _this.type = 'heatmap';\n    _this.domain = domain;\n    _this.subdomain = subdomain;\n    _this.data = data;\n    _this.discrete_domains = discrete_domains;\n    _this.count_label = count_label;\n    var today = new Date();\n    _this.start = start || _this.add_days(today, 365);\n    _this.legend_colors = ['#ebedf0', '#c6e48b', '#7bc96f', '#239a3b', '#196127'];\n    _this.translate_x = 0;\n\n    _this.setup();\n\n    return _this;\n  }\n\n  createClass(Heatmap, [{\n    key: 'setup_base_values',\n    value: function setup_base_values() {\n      this.today = new Date();\n\n      if (!this.start) {\n        this.start = new Date();\n        this.start.setFullYear(this.start.getFullYear() - 1);\n      }\n\n      this.first_week_start = new Date(this.start.toDateString());\n      this.last_week_start = new Date(this.today.toDateString());\n\n      if (this.first_week_start.getDay() !== 7) {\n        this.add_days(this.first_week_start, -1 * this.first_week_start.getDay());\n      }\n\n      if (this.last_week_start.getDay() !== 7) {\n        this.add_days(this.last_week_start, -1 * this.last_week_start.getDay());\n      }\n\n      this.no_of_cols = this.get_weeks_between(this.first_week_start + '', this.last_week_start + '') + 1;\n    }\n  }, {\n    key: 'set_width',\n    value: function set_width() {\n      this.base_width = (this.no_of_cols + 3) * 12;\n\n      if (this.discrete_domains) {\n        this.base_width += 12 * 12;\n      }\n    }\n  }, {\n    key: 'setup_components',\n    value: function setup_components() {\n      this.domain_label_group = $.createSVG(\"g\", {\n        className: \"domain-label-group chart-label\",\n        inside: this.draw_area\n      });\n      this.data_groups = $.createSVG(\"g\", {\n        className: \"data-groups\",\n        inside: this.draw_area,\n        transform: 'translate(0, 20)'\n      });\n    }\n  }, {\n    key: 'setup_values',\n    value: function setup_values() {\n      this.domain_label_group.textContent = '';\n      this.data_groups.textContent = '';\n      this.distribution = this.get_distribution(this.data, this.legend_colors);\n      this.month_names = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n      this.render_all_weeks_and_store_x_values(this.no_of_cols);\n    }\n  }, {\n    key: 'render_all_weeks_and_store_x_values',\n    value: function render_all_weeks_and_store_x_values(no_of_weeks) {\n      var current_week_sunday = new Date(this.first_week_start);\n      this.week_col = 0;\n      this.current_month = current_week_sunday.getMonth();\n      this.months = [this.current_month + ''];\n      this.month_weeks = {}, this.month_start_points = [];\n      this.month_weeks[this.current_month] = 0;\n      this.month_start_points.push(13);\n\n      for (var i = 0; i < no_of_weeks; i++) {\n        var data_group = void 0,\n            month_change = 0;\n        var day = new Date(current_week_sunday);\n\n        var _get_week_squares_gro = this.get_week_squares_group(day, this.week_col);\n\n        var _get_week_squares_gro2 = slicedToArray(_get_week_squares_gro, 2);\n\n        data_group = _get_week_squares_gro2[0];\n        month_change = _get_week_squares_gro2[1];\n        this.data_groups.appendChild(data_group);\n        this.week_col += 1 + parseInt(this.discrete_domains && month_change);\n        this.month_weeks[this.current_month]++;\n\n        if (month_change) {\n          this.current_month = (this.current_month + 1) % 12;\n          this.months.push(this.current_month + '');\n          this.month_weeks[this.current_month] = 1;\n        }\n\n        this.add_days(current_week_sunday, 7);\n      }\n\n      this.render_month_labels();\n    }\n  }, {\n    key: 'get_week_squares_group',\n    value: function get_week_squares_group(current_date, index) {\n      var no_of_weekdays = 7;\n      var square_side = 10;\n      var cell_padding = 2;\n      var step = 1;\n      var month_change = 0;\n      var week_col_change = 0;\n      var data_group = $.createSVG(\"g\", {\n        className: \"data-group\",\n        inside: this.data_groups\n      });\n\n      for (var y = 0, i = 0; i < no_of_weekdays; i += step, y += square_side + cell_padding) {\n        var data_value = 0;\n        var color_index = 0;\n        var current_timestamp = current_date.getTime() / 1000;\n        var timestamp = Math.floor(current_timestamp - current_timestamp % 86400).toFixed(1);\n\n        if (this.data[timestamp]) {\n          data_value = this.data[timestamp];\n          color_index = this.get_max_checkpoint(data_value, this.distribution);\n        }\n\n        if (this.data[Math.round(timestamp)]) {\n          data_value = this.data[Math.round(timestamp)];\n          color_index = this.get_max_checkpoint(data_value, this.distribution);\n        }\n\n        var x = 13 + (index + week_col_change) * 12;\n        $.createSVG(\"rect\", {\n          className: 'day',\n          inside: data_group,\n          x: x,\n          y: y,\n          width: square_side,\n          height: square_side,\n          fill: this.legend_colors[color_index],\n          'data-date': this.get_dd_mm_yyyy(current_date),\n          'data-value': data_value,\n          'data-day': current_date.getDay()\n        });\n        var next_date = new Date(current_date);\n        this.add_days(next_date, 1);\n\n        if (next_date.getMonth() - current_date.getMonth()) {\n          month_change = 1;\n\n          if (this.discrete_domains) {\n            week_col_change = 1;\n          }\n\n          this.month_start_points.push(13 + (index + week_col_change) * 12);\n        }\n\n        current_date = next_date;\n      }\n\n      return [data_group, month_change];\n    }\n  }, {\n    key: 'render_month_labels',\n    value: function render_month_labels() {\n      var _this2 = this; // this.first_month_label = 1;\n      // if (this.first_week_start.getDate() > 8) {\n      // \tthis.first_month_label = 0;\n      // }\n      // this.last_month_label = 1;\n      // let first_month = this.months.shift();\n      // let first_month_start = this.month_start_points.shift();\n      // render first month if\n      // let last_month = this.months.pop();\n      // let last_month_start = this.month_start_points.pop();\n      // render last month if\n\n\n      this.months.shift();\n      this.month_start_points.shift();\n      this.months.pop();\n      this.month_start_points.pop();\n      this.month_start_points.map(function (start, i) {\n        var month_name = _this2.month_names[_this2.months[i]].substring(0, 3);\n\n        $.createSVG('text', {\n          className: 'y-value-text',\n          inside: _this2.domain_label_group,\n          x: start + 12,\n          y: 10,\n          dy: '.32em',\n          innerHTML: month_name\n        });\n      });\n    }\n  }, {\n    key: 'make_graph_components',\n    value: function make_graph_components() {\n      Array.prototype.slice.call(this.container.querySelectorAll('.graph-stats-container, .sub-title, .title')).map(function (d) {\n        d.style.display = 'None';\n      });\n      this.chart_wrapper.style.marginTop = '0px';\n      this.chart_wrapper.style.paddingTop = '0px';\n    }\n  }, {\n    key: 'bind_tooltip',\n    value: function bind_tooltip() {\n      var _this3 = this;\n\n      Array.prototype.slice.call(document.querySelectorAll(\".data-group .day\")).map(function (el) {\n        el.addEventListener('mouseenter', function (e) {\n          var count = e.target.getAttribute('data-value');\n          var date_parts = e.target.getAttribute('data-date').split('-');\n\n          var month = _this3.month_names[parseInt(date_parts[1]) - 1].substring(0, 3);\n\n          var g_off = _this3.chart_wrapper.getBoundingClientRect(),\n              p_off = e.target.getBoundingClientRect();\n\n          var width = parseInt(e.target.getAttribute('width'));\n          var x = p_off.left - g_off.left + (width + 2) / 2;\n          var y = p_off.top - g_off.top - (width + 2) / 2;\n          var value = count + ' ' + _this3.count_label;\n          var name = ' on ' + month + ' ' + date_parts[0] + ', ' + date_parts[2];\n\n          _this3.tip.set_values(x, y, name, value, [], 1);\n\n          _this3.tip.show_tip();\n        });\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update(data) {\n      this.data = data;\n      this.setup_values();\n      this.bind_tooltip();\n    }\n  }, {\n    key: 'get_distribution',\n    value: function get_distribution() {\n      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var mapper_array = arguments[1];\n      var data_values = Object.keys(data).map(function (key) {\n        return data[key];\n      });\n      var data_max_value = Math.max.apply(Math, toConsumableArray(data_values));\n      var distribution_step = 1 / (mapper_array.length - 1);\n      var distribution = [];\n      mapper_array.map(function (color, i) {\n        var checkpoint = data_max_value * (distribution_step * i);\n        distribution.push(checkpoint);\n      });\n      return distribution;\n    }\n  }, {\n    key: 'get_max_checkpoint',\n    value: function get_max_checkpoint(value, distribution) {\n      return distribution.filter(function (d, i) {\n        if (i === 1) {\n          return distribution[0] < value;\n        }\n\n        return d <= value;\n      }).length - 1;\n    } // TODO: date utils, move these out\n    // https://stackoverflow.com/a/11252167/6495043\n\n  }, {\n    key: 'treat_as_utc',\n    value: function treat_as_utc(date_str) {\n      var result = new Date(date_str);\n      result.setMinutes(result.getMinutes() - result.getTimezoneOffset());\n      return result;\n    }\n  }, {\n    key: 'get_dd_mm_yyyy',\n    value: function get_dd_mm_yyyy(date) {\n      var dd = date.getDate();\n      var mm = date.getMonth() + 1; // getMonth() is zero-based\n\n      return [(dd > 9 ? '' : '0') + dd, (mm > 9 ? '' : '0') + mm, date.getFullYear()].join('-');\n    }\n  }, {\n    key: 'get_weeks_between',\n    value: function get_weeks_between(start_date_str, end_date_str) {\n      return Math.ceil(this.get_days_between(start_date_str, end_date_str) / 7);\n    }\n  }, {\n    key: 'get_days_between',\n    value: function get_days_between(start_date_str, end_date_str) {\n      var milliseconds_per_day = 24 * 60 * 60 * 1000;\n      return (this.treat_as_utc(end_date_str) - this.treat_as_utc(start_date_str)) / milliseconds_per_day;\n    } // mutates\n\n  }, {\n    key: 'add_days',\n    value: function add_days(date, number_of_days) {\n      date.setDate(date.getDate() + number_of_days);\n    }\n  }, {\n    key: 'get_month_name',\n    value: function get_month_name() {}\n  }]);\n  return Heatmap;\n}(BaseChart); // if (\"development\" !== 'production') {\n// \t// Enable LiveReload\n// \tdocument.write(\n// \t\t'<script src=\"http://' + (location.host || 'localhost').split(':')[0] +\n// \t\t':35729/livereload.js?snipver=1\"></' + 'script>'\n// \t);\n// }\n\n\nvar chartTypes = {\n  line: LineChart,\n  bar: BarChart,\n  scatter: ScatterChart,\n  percentage: PercentageChart,\n  heatmap: Heatmap,\n  pie: PieChart\n};\n\nfunction getChartByType() {\n  var chartType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'line';\n  var options = arguments[1];\n\n  if (!chartTypes[chartType]) {\n    return new LineChart(options);\n  }\n\n  return new chartTypes[chartType](options);\n}\n\nvar Chart = function Chart(args) {\n  classCallCheck(this, Chart);\n  return getChartByType(args.type, arguments[0]);\n};\n\nexport default Chart;","map":null,"metadata":{},"sourceType":"module"}